# 1001 行事曆作業

## 設計理念

### 為什麼記錄每一天？

傳統設計只記錄「例外日期」（假日、補班日），依賴程式邏輯判斷是否為工作日。但這個設計有嚴重問題：

**問題場景：**
```
2025年：週一到週五是工作日（週休二日）
2030年：改為週一到週四是工作日（週休三日）

查詢 2025-05-16（週五）：
- 系統無記錄
- 依照「當前規則」（週休三日），判斷為休息日 ❌ 錯誤！
- 實際上 2025 年週五是工作日 ✓
```

**解決方案：記錄每一天**
- 一年 365 筆，10 年 3,650 筆，資料量極小
- 每天都有明確記錄，不會因規則變更而產生歧義
- 查詢效率高，不需複雜的判斷邏輯
- 完整的歷史追溯與審計軌跡

## 工作日規則設定

使用 `config/hrm.php` 設定檔定義工作日規則，支援歷史規則追溯：

```php
// config/hrm.php

return [
    /*
    |--------------------------------------------------------------------------
    | 工作日規則
    |--------------------------------------------------------------------------
    | 定義不同時期的工作日規則。支援多組規則以處理政策變更。
    | 系統會依據日期自動選擇適用的規則。
    |
    */
    'workday_rules' => [
        // 當前規則（週休二日）
        [
            'from' => '2020-01-01',        // 生效起始日
            'to' => null,                  // null = 目前生效中
            'workdays' => [1, 2, 3, 4, 5], // 週一到週五（0=日,1=一...6=六）
            'work_start' => '09:00',       // 預設上班時間
            'work_end' => '18:00',         // 預設下班時間
            'work_minutes' => 480,         // 預設工作分鐘數（8小時）
            'description' => '標準週休二日制',
        ],

        // 範例：未來政策（週休三日）- 尚未啟用
        // [
        //     'from' => '2030-01-01',
        //     'to' => null,
        //     'workdays' => [1, 2, 3, 4],    // 週一到週四
        //     'work_start' => '09:00',
        //     'work_end' => '19:00',
        //     'work_minutes' => 540,         // 10小時
        //     'description' => '週休三日制',
        // ],
    ],

    /*
    |--------------------------------------------------------------------------
    | 行事曆顏色設定
    |--------------------------------------------------------------------------
    */
    'calendar_colors' => [
        'national_holiday' => '#FF5733',  // 國定假日（紅色）
        'typhoon_day' => '#3498DB',       // 颱風假（藍色）
        'company_holiday' => '#9B59B6',   // 公司休假（紫色）
        'makeup_workday' => '#F39C12',    // 補班日（橘色）
        'special_workday' => '#16A085',   // 特殊工作日（綠色）
        'weekend' => '#95A5A6',           // 週末（灰色）
    ],
];
```

### 規則說明

**workdays 陣列**：0=週日, 1=週一, 2=週二, ..., 6=週六
- `[1, 2, 3, 4, 5]`：週一到週五（週休二日）
- `[1, 2, 3, 4]`：週一到週四（週休三日）
- `[1, 2, 3, 4, 5, 6]`：週一到週六（週休一日）

**時間範圍**：
- `from`：規則生效起始日
- `to`：規則結束日（null 表示目前生效中）
- 系統會自動選擇適用的規則

**歷史追溯範例**：
```php
'workday_rules' => [
    // 2020-2029：週休二日
    [
        'from' => '2020-01-01',
        'to' => '2029-12-31',
        'workdays' => [1, 2, 3, 4, 5],
    ],
    // 2030起：週休三日
    [
        'from' => '2030-01-01',
        'to' => null,
        'workdays' => [1, 2, 3, 4],
    ],
],
```

查詢 `2025-10-10（五）`：套用第一個規則 → 工作日
查詢 `2030-10-10（五）`：套用第二個規則 → 休息日

## 資料表結構

### hrm_calendar_days（每日行事曆）

記錄每一天的實際狀態：

```php
Schema::create('hrm_calendar_days', function (Blueprint $table) {
    $table->id();
    $table->date('date')->unique()->comment('日期');

    // 日期類型
    $table->enum('day_type', [
        'regular',            // 一般日（依規則產生）
        'national_holiday',   // 國定假日
        'typhoon_day',        // 颱風假
        'company_holiday',    // 公司休假
        'makeup_workday',     // 補班日
        'special_workday',    // 特殊工作日
    ])->default('regular')->comment('日期類型');

    $table->boolean('is_workday')->comment('是否為工作日');

    $table->string('name', 100)->nullable()->comment('名稱');
    $table->text('description')->nullable()->comment('詳細說明');
    $table->string('color', 7)->nullable()->comment('行事曆顯示顏色（HEX）');

    // 當日的工作時間設定（可覆蓋預設值）
    $table->time('work_start')->nullable()->comment('上班時間');
    $table->time('work_end')->nullable()->comment('下班時間');
    $table->integer('work_minutes')->nullable()->comment('工作分鐘數');

    // 產生方式
    $table->enum('generated_by', [
        'system',    // 系統自動產生
        'import',    // 批次匯入
        'manual',    // 手動建立
    ])->default('system')->comment('產生方式');

    $table->timestamps();
    $table->softDeletes();

    $table->index('date');
    $table->index(['is_workday', 'date']);
    $table->index('day_type');
});
```

## 核心邏輯

### 1. 取得日期資訊（自動建立）

```php
class CalendarDayService
{
    /**
     * 取得指定日期的行事曆資訊
     * 如果不存在，自動建立
     */
    public function getOrCreateDay(Carbon $date): CalendarDay
    {
        $dateString = $date->format('Y-m-d');

        // 嘗試取得現有記錄
        $calendarDay = CalendarDay::where('date', $dateString)->first();

        if ($calendarDay) {
            return $calendarDay;
        }

        // 不存在則自動建立
        return $this->createDayByRule($date);
    }

    /**
     * 依據規則建立日期記錄
     */
    protected function createDayByRule(Carbon $date): CalendarDay
    {
        // 從 config 取得該日期適用的規則
        $rule = $this->getEffectiveRule($date);

        if (!$rule) {
            throw new \Exception('無法找到適用的工作日規則');
        }

        // 判斷是否為工作日
        $weekday = $date->dayOfWeek; // 0=日, 1=一, ..., 6=六
        $isWorkday = in_array($weekday, $rule['workdays']);

        // 建立記錄
        return CalendarDay::create([
            'date' => $date->format('Y-m-d'),
            'day_type' => 'regular',
            'is_workday' => $isWorkday,
            'work_start' => $rule['work_start'],
            'work_end' => $rule['work_end'],
            'work_minutes' => $rule['work_minutes'],
            'generated_by' => 'system',
        ]);
    }

    /**
     * 從 config 取得指定日期適用的規則
     */
    protected function getEffectiveRule(Carbon $date): ?array
    {
        $rules = config('hrm.workday_rules', []);
        $dateString = $date->format('Y-m-d');

        // 找出適用的規則（日期在範圍內）
        foreach ($rules as $rule) {
            $from = $rule['from'];
            $to = $rule['to'] ?? '9999-12-31'; // null 視為無限期

            if ($dateString >= $from && $dateString <= $to) {
                return $rule;
            }
        }

        // 找不到適用規則時，使用最新的規則
        return end($rules) ?: null;
    }
}
```

### 2. 批次產生未來日期（排程）

```php
class GenerateFutureCalendarDays extends Command
{
    protected $signature = 'calendar:generate {--months=3}';
    protected $description = '產生未來 N 個月的行事曆記錄';

    public function handle(CalendarDayService $service)
    {
        $months = $this->option('months');
        $startDate = Carbon::today();
        $endDate = Carbon::today()->addMonths($months);

        $this->info("產生 {$startDate->format('Y-m-d')} 到 {$endDate->format('Y-m-d')} 的行事曆記錄");

        $created = 0;
        $skipped = 0;

        $currentDate = $startDate->copy();
        while ($currentDate <= $endDate) {
            // 檢查是否已存在
            $exists = CalendarDay::where('date', $currentDate->format('Y-m-d'))->exists();

            if (!$exists) {
                $service->getOrCreateDay($currentDate);
                $created++;
            } else {
                $skipped++;
            }

            $currentDate->addDay();
        }

        $this->info("完成！新增 {$created} 筆，略過 {$skipped} 筆（已存在）");
    }
}
```

### 3. 排程設定

在 `app/Console/Kernel.php` 中註冊排程：

```php
protected function schedule(Schedule $schedule)
{
    // 每週一早上 2 點，產生未來 3 個月的行事曆
    $schedule->command('calendar:generate --months=3')
        ->weeklyOn(1, '02:00')
        ->withoutOverlapping();

    // 或每月 1 號執行
    $schedule->command('calendar:generate --months=3')
        ->monthlyOn(1, '02:00')
        ->withoutOverlapping();
}
```

### 4. 批次產生歷史資料（Seeder）

```php
class CalendarDaySeeder extends Seeder
{
    public function run()
    {
        $service = app(CalendarDayService::class);

        // 產生過去一年到未來六個月的記錄
        $startDate = Carbon::today()->subYear();
        $endDate = Carbon::today()->addMonths(6);

        $currentDate = $startDate->copy();
        while ($currentDate <= $endDate) {
            $service->getOrCreateDay($currentDate);
            $currentDate->addDay();
        }

        $this->command->info('行事曆基礎資料建立完成');

        // 匯入特殊日期（國定假日等）
        $this->importSpecialDays();
    }

    protected function importSpecialDays()
    {
        // 2025 年台灣國定假日
        $holidays = [
            ['date' => '2025-01-01', 'name' => '中華民國開國紀念日'],
            ['date' => '2025-01-27', 'name' => '農曆除夕'],
            ['date' => '2025-01-28', 'name' => '春節'],
            ['date' => '2025-01-29', 'name' => '春節'],
            ['date' => '2025-01-30', 'name' => '春節'],
            ['date' => '2025-02-28', 'name' => '和平紀念日'],
            ['date' => '2025-04-04', 'name' => '兒童節及清明節'],
            ['date' => '2025-05-31', 'name' => '端午節'],
            ['date' => '2025-10-07', 'name' => '中秋節'],
            ['date' => '2025-10-10', 'name' => '國慶日'],
        ];

        foreach ($holidays as $holiday) {
            CalendarDay::where('date', $holiday['date'])->update([
                'day_type' => 'national_holiday',
                'is_workday' => false,
                'name' => $holiday['name'],
                'color' => '#FF5733',
                'generated_by' => 'import',
            ]);
        }

        // 補班日
        $makeupDays = [
            ['date' => '2025-01-18', 'name' => '春節補班'],
            ['date' => '2025-06-21', 'name' => '端午節補班'],
        ];

        foreach ($makeupDays as $day) {
            CalendarDay::where('date', $day['date'])->update([
                'day_type' => 'makeup_workday',
                'is_workday' => true,
                'name' => $day['name'],
                'color' => '#F39C12',
                'generated_by' => 'import',
            ]);
        }
    }
}
```

## 日期類型說明

| 類型 | 說明 | is_workday | 範例 |
|------|------|------------|------|
| regular | 一般日（依規則產生）| 依規則 | 週一到週五（工作日）<br>週六日（休息日）|
| national_holiday | 國定假日 | false | 元旦、春節、國慶日 |
| typhoon_day | 颱風假 | false | 政府宣布停班停課 |
| company_holiday | 公司休假 | false | 員工旅遊、尾牙 |
| makeup_workday | 補班日 | true | 連假補班（週六上班）|
| special_workday | 特殊工作日 | true | 臨時加班日 |

## 功能需求

### 1. 日曆管理

#### 查詢日曆
```php
// 取得單日資訊（自動建立）
GET /api/hrm/calendar/days/2025-10-10

// 取得指定月份
GET /api/hrm/calendar/days?year_month=2025-10

// 取得日期區間
GET /api/hrm/calendar/days?start_date=2025-10-01&end_date=2025-10-31

// 取得工作日清單
GET /api/hrm/calendar/workdays?start_date=2025-10-01&end_date=2025-10-31
```

#### 修改特殊日期
```php
// 設定為國定假日
PUT /api/hrm/calendar/days/2025-10-10
{
    "day_type": "national_holiday",
    "is_workday": false,
    "name": "國慶日",
    "color": "#FF5733"
}

// 設定為補班日
PUT /api/hrm/calendar/days/2025-06-21
{
    "day_type": "makeup_workday",
    "is_workday": true,
    "name": "端午節補班",
    "color": "#F39C12"
}

// 還原為一般日（重新依規則產生）
POST /api/hrm/calendar/days/2025-10-10/reset
```

### 2. 批次操作
```php
// 批次匯入特殊日期（CSV）
POST /api/hrm/calendar/import

// 產生未來日期
POST /api/hrm/calendar/generate
{
    "months": 6  // 產生未來 6 個月
}

// 重新產生指定區間（覆蓋現有）
POST /api/hrm/calendar/regenerate
{
    "start_date": "2025-10-01",
    "end_date": "2025-10-31",
    "preserve_special": true  // 保留特殊日期（假日、補班日）
}
```

## 前端介面

### 月曆檢視

```vue
<template>
  <div class="calendar-container">
    <!-- 工具列 -->
    <div class="calendar-toolbar">
      <button @click="prevMonth">上個月</button>
      <span>{{ currentMonth }}</span>
      <button @click="nextMonth">下個月</button>

      <button @click="importSpecialDays">匯入特殊日期</button>
      <button @click="generateFuture">產生未來日期</button>
    </div>

    <!-- 月曆 -->
    <FullCalendar
      :options="calendarOptions"
      :events="calendarEvents"
      @dateClick="handleDateClick"
    />

    <!-- 編輯對話框 -->
    <CalendarDayDialog
      v-model="showDialog"
      :date="selectedDate"
      @saved="reloadCalendar"
    />
  </div>
</template>

<script setup>
const calendarEvents = computed(() => {
  return days.value.map(day => {
    // 一般工作日不顯示
    if (day.day_type === 'regular' && day.is_workday) {
      return null
    }

    return {
      title: day.name || getDayTypeLabel(day.day_type),
      date: day.date,
      backgroundColor: day.color || getDefaultColor(day.day_type),
      extendedProps: {
        dayType: day.day_type,
        isWorkday: day.is_workday
      }
    }
  }).filter(Boolean)
})

function getDayTypeLabel(type) {
  const labels = {
    'regular': '一般',
    'national_holiday': '國定假日',
    'typhoon_day': '颱風假',
    'company_holiday': '公司休假',
    'makeup_workday': '補班',
    'special_workday': '特殊工作日'
  }
  return labels[type] || type
}

function getDefaultColor(type) {
  const colors = {
    'national_holiday': '#FF5733',
    'typhoon_day': '#3498DB',
    'company_holiday': '#9B59B6',
    'makeup_workday': '#F39C12',
    'special_workday': '#16A085',
    'regular': '#95A5A6'  // 週末休息日
  }
  return colors[type] || '#95A5A6'
}
</script>
```

## 測試案例

```php
class CalendarDayServiceTest extends TestCase
{
    /** @test */
    public function it_auto_creates_calendar_day_when_not_exists()
    {
        // 設定 config（在 config/hrm.php 或測試中覆寫）
        config(['hrm.workday_rules' => [
            [
                'from' => '2020-01-01',
                'to' => null,
                'workdays' => [1, 2, 3, 4, 5], // 週一到週五
                'work_start' => '09:00',
                'work_end' => '18:00',
                'work_minutes' => 480,
            ]
        ]]);

        $service = app(CalendarDayService::class);

        // 取得週三（應該是工作日）
        $day = $service->getOrCreateDay(Carbon::parse('2025-10-08'));
        $this->assertTrue($day->is_workday);
        $this->assertEquals('regular', $day->day_type);

        // 取得週六（應該是休息日）
        $day = $service->getOrCreateDay(Carbon::parse('2025-10-11'));
        $this->assertFalse($day->is_workday);
    }

    /** @test */
    public function it_respects_rule_changes()
    {
        // 設定兩組規則：2025年週休二日，2030年週休三日
        config(['hrm.workday_rules' => [
            [
                'from' => '2020-01-01',
                'to' => '2029-12-31',
                'workdays' => [1, 2, 3, 4, 5], // 週一到週五
            ],
            [
                'from' => '2030-01-01',
                'to' => null,
                'workdays' => [1, 2, 3, 4], // 週一到週四
            ],
        ]]);

        $service = app(CalendarDayService::class);

        // 2025年的週五是工作日
        $day = $service->getOrCreateDay(Carbon::parse('2025-10-10'));
        $this->assertTrue($day->is_workday);

        // 2030年的週五是休息日
        $day = $service->getOrCreateDay(Carbon::parse('2030-10-10'));
        $this->assertFalse($day->is_workday);
    }

    /** @test */
    public function it_can_generate_future_days()
    {
        config(['hrm.workday_rules' => [
            [
                'from' => '2020-01-01',
                'to' => null,
                'workdays' => [1, 2, 3, 4, 5],
            ]
        ]]);

        Artisan::call('calendar:generate', ['--months' => 3]);

        $count = CalendarDay::whereBetween('date', [
            Carbon::today(),
            Carbon::today()->addMonths(3)
        ])->count();

        $this->assertGreaterThan(90, $count); // 至少 90 天
    }
}
```

## 效能考量

### 查詢優化

```php
// 快取當月行事曆（減少資料庫查詢）
$cacheKey = "calendar_days_{$yearMonth}";
$days = Cache::remember($cacheKey, 3600, function() use ($yearMonth) {
    return CalendarDay::whereYear('date', $year)
        ->whereMonth('date', $month)
        ->get();
});
```

### 索引策略

```sql
-- 日期查詢（最常用）
CREATE INDEX idx_date ON hrm_calendar_days(date);

-- 工作日篩選
CREATE INDEX idx_workday_date ON hrm_calendar_days(is_workday, date);

-- 日期類型篩選
CREATE INDEX idx_day_type ON hrm_calendar_days(day_type);
```

## 監控與維護

### 資料完整性檢查

```php
class CheckCalendarIntegrity extends Command
{
    protected $signature = 'calendar:check';

    public function handle()
    {
        // 檢查未來 30 天是否都有記錄
        $missingDates = [];
        $startDate = Carbon::today();
        $endDate = Carbon::today()->addDays(30);

        $currentDate = $startDate->copy();
        while ($currentDate <= $endDate) {
            $exists = CalendarDay::where('date', $currentDate->format('Y-m-d'))->exists();
            if (!$exists) {
                $missingDates[] = $currentDate->format('Y-m-d');
            }
            $currentDate->addDay();
        }

        if (empty($missingDates)) {
            $this->info('✓ 行事曆資料完整');
        } else {
            $this->warn('✗ 缺少以下日期的記錄：');
            foreach ($missingDates as $date) {
                $this->line("  - {$date}");
            }
            $this->info('執行 php artisan calendar:generate 來產生遺漏的日期');
        }
    }
}
```

### 定期清理舊資料（可選）

```php
// 如果需要，可以清理過於久遠的資料（如 10 年前）
class CleanOldCalendarDays extends Command
{
    protected $signature = 'calendar:clean {--years=10}';

    public function handle()
    {
        $years = $this->option('years');
        $cutoffDate = Carbon::today()->subYears($years);

        $count = CalendarDay::where('date', '<', $cutoffDate)->delete();

        $this->info("已刪除 {$count} 筆 {$years} 年前的行事曆記錄");
    }
}
```

## 總結

### 設計優勢

✅ **完整的歷史記錄**：每天都有明確狀態，不受未來規則變更影響
✅ **自動建立機制**：查詢時自動建立，無需擔心遺漏
✅ **排程預先產生**：定期產生未來記錄，確保資料完整
✅ **規則變更友善**：新規則只影響未來，歷史資料不變
✅ **查詢效率高**：簡單的日期查詢，不需複雜邏輯判斷
✅ **Config 管理規則**：簡單直接，透過 Git 版本控制，無需額外資料表
✅ **部署容易**：修改 config 即可，不需要資料庫遷移

### 實作重點

1. **初次部署**：執行 Seeder 產生歷史與未來資料
2. **定期排程**：每週或每月自動產生未來 3 個月
3. **完整性檢查**：監控是否有遺漏的日期
4. **規則管理**：謹慎處理工作日規則變更
5. **效能優化**：使用快取減少重複查詢
